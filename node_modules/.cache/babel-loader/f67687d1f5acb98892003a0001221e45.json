{"ast":null,"code":"import { O as Ollama$1, h as head, p as post } from './shared/ollama.be8fd0da.mjs';\nimport defaultExport from './node_modules/ollama/dist/index.mjs';\nimport fs, { promises, createReadStream } from 'fs';\nimport { resolve, join, dirname } from 'path';\nimport { createHash } from 'crypto';\nimport { homedir } from 'os';\nimport 'whatwg-fetch';\n\nclass Ollama extends Ollama$1 {\n  async encodeImage(image) {\n    if (typeof image !== \"string\") {\n      const result = Buffer.from(image).toString(\"base64\");\n      return result;\n    }\n\n    try {\n      if (fs.existsSync(image)) {\n        const fileBuffer = await promises.readFile(resolve(image));\n        return Buffer.from(fileBuffer).toString(\"base64\");\n      }\n    } catch {}\n\n    return image;\n  }\n\n  async parseModelfile(modelfile, mfDir = process.cwd()) {\n    const out = [];\n    const lines = modelfile.split(\"\\n\");\n\n    for (const line of lines) {\n      const [command, args] = line.split(\" \", 2);\n\n      if ([\"FROM\", \"ADAPTER\"].includes(command.toUpperCase())) {\n        const path = this.resolvePath(args.trim(), mfDir);\n\n        if (await this.fileExists(path)) {\n          out.push(`${command} @${await this.createBlob(path)}`);\n        } else {\n          out.push(`${command} ${args}`);\n        }\n      } else {\n        out.push(line);\n      }\n    }\n\n    return out.join(\"\\n\");\n  }\n\n  resolvePath(inputPath, mfDir) {\n    if (inputPath.startsWith(\"~\")) {\n      return join(homedir(), inputPath.slice(1));\n    }\n\n    return resolve(mfDir, inputPath);\n  }\n\n  async fileExists(path) {\n    try {\n      await promises.access(path);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  async createBlob(path) {\n    if (typeof ReadableStream === \"undefined\") {\n      throw new Error(\"Streaming uploads are not supported in this environment.\");\n    }\n\n    const fileStream = createReadStream(path);\n    const sha256sum = await new Promise((resolve2, reject) => {\n      const hash = createHash(\"sha256\");\n      fileStream.on(\"data\", data => hash.update(data));\n      fileStream.on(\"end\", () => resolve2(hash.digest(\"hex\")));\n      fileStream.on(\"error\", reject);\n    });\n    const digest = `sha256:${sha256sum}`;\n\n    try {\n      await head(this.fetch, `${this.config.host}/api/blobs/${digest}`);\n    } catch (e) {\n      if (e instanceof Error && e.message.includes(\"404\")) {\n        const readableStream = new ReadableStream({\n          start(controller) {\n            fileStream.on(\"data\", chunk => {\n              controller.enqueue(chunk);\n            });\n            fileStream.on(\"end\", () => {\n              controller.close();\n            });\n            fileStream.on(\"error\", err => {\n              controller.error(err);\n            });\n          }\n\n        });\n        await post(this.fetch, `${this.config.host}/api/blobs/${digest}`, readableStream);\n      } else {\n        throw e;\n      }\n    }\n\n    return digest;\n  }\n\n  async create(request) {\n    let modelfileContent = \"\";\n\n    if (request.path) {\n      modelfileContent = await promises.readFile(request.path, {\n        encoding: \"utf8\"\n      });\n      modelfileContent = await this.parseModelfile(modelfileContent, dirname(request.path));\n    } else if (request.modelfile) {\n      modelfileContent = await this.parseModelfile(request.modelfile);\n    } else {\n      throw new Error(\"Must provide either path or modelfile to create a model\");\n    }\n\n    request.modelfile = modelfileContent;\n\n    if (request.stream) {\n      return super.create(request);\n    } else {\n      return super.create(request);\n    }\n  }\n\n}\n\nconst index = new Ollama();\nexport { Ollama, index as default };","map":{"version":3,"sources":["C:/Users/firdoz/Desktop/g project/New folder/learn_it/node_modules/ollama/dist/index.mjs"],"names":["O","Ollama$1","h","head","p","post","defaultExport","fs","promises","createReadStream","resolve","join","dirname","createHash","homedir","Ollama","encodeImage","image","result","Buffer","from","toString","existsSync","fileBuffer","readFile","parseModelfile","modelfile","mfDir","process","cwd","out","lines","split","line","command","args","includes","toUpperCase","path","resolvePath","trim","fileExists","push","createBlob","inputPath","startsWith","slice","access","ReadableStream","Error","fileStream","sha256sum","Promise","resolve2","reject","hash","on","data","update","digest","fetch","config","host","e","message","readableStream","start","controller","chunk","enqueue","close","err","error","create","request","modelfileContent","encoding","stream","index","default"],"mappings":"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","sourcesContent":["import { O as Ollama$1, h as head, p as post } from './shared/ollama.be8fd0da.mjs';\nimport defaultExport from './node_modules/ollama/dist/index.mjs';\nimport fs, { promises, createReadStream } from 'fs';\nimport { resolve, join, dirname } from 'path';\nimport { createHash } from 'crypto';\nimport { homedir } from 'os';\nimport 'whatwg-fetch';\n\nclass Ollama extends Ollama$1 {\n  async encodeImage(image) {\n    if (typeof image !== \"string\") {\n      const result = Buffer.from(image).toString(\"base64\");\n      return result;\n    }\n    try {\n      if (fs.existsSync(image)) {\n        const fileBuffer = await promises.readFile(resolve(image));\n        return Buffer.from(fileBuffer).toString(\"base64\");\n      }\n    } catch {\n    }\n    return image;\n  }\n  async parseModelfile(modelfile, mfDir = process.cwd()) {\n    const out = [];\n    const lines = modelfile.split(\"\\n\");\n    for (const line of lines) {\n      const [command, args] = line.split(\" \", 2);\n      if ([\"FROM\", \"ADAPTER\"].includes(command.toUpperCase())) {\n        const path = this.resolvePath(args.trim(), mfDir);\n        if (await this.fileExists(path)) {\n          out.push(`${command} @${await this.createBlob(path)}`);\n        } else {\n          out.push(`${command} ${args}`);\n        }\n      } else {\n        out.push(line);\n      }\n    }\n    return out.join(\"\\n\");\n  }\n  resolvePath(inputPath, mfDir) {\n    if (inputPath.startsWith(\"~\")) {\n      return join(homedir(), inputPath.slice(1));\n    }\n    return resolve(mfDir, inputPath);\n  }\n  async fileExists(path) {\n    try {\n      await promises.access(path);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n  async createBlob(path) {\n    if (typeof ReadableStream === \"undefined\") {\n      throw new Error(\"Streaming uploads are not supported in this environment.\");\n    }\n    const fileStream = createReadStream(path);\n    const sha256sum = await new Promise((resolve2, reject) => {\n      const hash = createHash(\"sha256\");\n      fileStream.on(\"data\", (data) => hash.update(data));\n      fileStream.on(\"end\", () => resolve2(hash.digest(\"hex\")));\n      fileStream.on(\"error\", reject);\n    });\n    const digest = `sha256:${sha256sum}`;\n    try {\n      await head(this.fetch, `${this.config.host}/api/blobs/${digest}`);\n    } catch (e) {\n      if (e instanceof Error && e.message.includes(\"404\")) {\n        const readableStream = new ReadableStream({\n          start(controller) {\n            fileStream.on(\"data\", (chunk) => {\n              controller.enqueue(chunk);\n            });\n            fileStream.on(\"end\", () => {\n              controller.close();\n            });\n            fileStream.on(\"error\", (err) => {\n              controller.error(err);\n            });\n          }\n        });\n        await post(\n          this.fetch,\n          `${this.config.host}/api/blobs/${digest}`,\n          readableStream\n        );\n      } else {\n        throw e;\n      }\n    }\n    return digest;\n  }\n  async create(request) {\n    let modelfileContent = \"\";\n    if (request.path) {\n      modelfileContent = await promises.readFile(request.path, { encoding: \"utf8\" });\n      modelfileContent = await this.parseModelfile(\n        modelfileContent,\n        dirname(request.path)\n      );\n    } else if (request.modelfile) {\n      modelfileContent = await this.parseModelfile(request.modelfile);\n    } else {\n      throw new Error(\"Must provide either path or modelfile to create a model\");\n    }\n    request.modelfile = modelfileContent;\n    if (request.stream) {\n      return super.create(request);\n    } else {\n      return super.create(request);\n    }\n  }\n}\nconst index = new Ollama();\n\nexport { Ollama, index as default };\n"]},"metadata":{},"sourceType":"module"}