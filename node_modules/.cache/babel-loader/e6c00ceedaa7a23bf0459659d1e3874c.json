{"ast":null,"code":"import 'whatwg-fetch';\nconst version = \"0.5.0\";\n\nclass ResponseError extends Error {\n  constructor(error, status_code) {\n    super(error);\n    this.error = error;\n    this.status_code = status_code;\n    this.name = \"ResponseError\";\n\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, ResponseError);\n    }\n  }\n\n}\n\nconst checkOk = async response => {\n  if (!response.ok) {\n    let message = `Error ${response.status}: ${response.statusText}`;\n    let errorData = null;\n\n    if (response.headers.get(\"content-type\")?.includes(\"application/json\")) {\n      try {\n        errorData = await response.json();\n        message = errorData.error || message;\n      } catch (error) {\n        console.log(\"Failed to parse error response as JSON\");\n      }\n    } else {\n      try {\n        console.log(\"Getting text from response\");\n        const textResponse = await response.text();\n        message = textResponse || message;\n      } catch (error) {\n        console.log(\"Failed to get text from error response\");\n      }\n    }\n\n    throw new ResponseError(message, response.status);\n  }\n};\n\nfunction getPlatform() {\n  if (typeof window !== \"undefined\" && window.navigator) {\n    return `${window.navigator.platform.toLowerCase()} Browser/${navigator.userAgent};`;\n  } else if (typeof process !== \"undefined\") {\n    return `${process.arch} ${process.platform} Node.js/${process.version}`;\n  }\n\n  return \"\";\n}\n\nconst fetchWithHeaders = async (fetch, url, options = {}) => {\n  const defaultHeaders = {\n    \"Content-Type\": \"application/json\",\n    Accept: \"application/json\",\n    \"User-Agent\": `ollama-js/${version} (${getPlatform()})`\n  };\n\n  if (!options.headers) {\n    options.headers = {};\n  }\n\n  options.headers = { ...defaultHeaders,\n    ...options.headers\n  };\n  return fetch(url, options);\n};\n\nconst get = async (fetch, host) => {\n  const response = await fetchWithHeaders(fetch, host);\n  await checkOk(response);\n  return response;\n};\n\nconst head = async (fetch, host) => {\n  const response = await fetchWithHeaders(fetch, host, {\n    method: \"HEAD\"\n  });\n  await checkOk(response);\n  return response;\n};\n\nconst post = async (fetch, host, data, options) => {\n  const isRecord = input => {\n    return input !== null && typeof input === \"object\" && !Array.isArray(input);\n  };\n\n  const formattedData = isRecord(data) ? JSON.stringify(data) : data;\n  const response = await fetchWithHeaders(fetch, host, {\n    method: \"POST\",\n    body: formattedData,\n    signal: options?.signal\n  });\n  await checkOk(response);\n  return response;\n};\n\nconst del = async (fetch, host, data) => {\n  const response = await fetchWithHeaders(fetch, host, {\n    method: \"DELETE\",\n    body: JSON.stringify(data)\n  });\n  await checkOk(response);\n  return response;\n};\n\nconst parseJSON = async function* (itr) {\n  const decoder = new TextDecoder(\"utf-8\");\n  let buffer = \"\";\n  const reader = itr.getReader();\n\n  while (true) {\n    const {\n      done,\n      value: chunk\n    } = await reader.read();\n\n    if (done) {\n      break;\n    }\n\n    buffer += decoder.decode(chunk);\n    const parts = buffer.split(\"\\n\");\n    buffer = parts.pop() ?? \"\";\n\n    for (const part of parts) {\n      try {\n        yield JSON.parse(part);\n      } catch (error) {\n        console.warn(\"invalid json: \", part);\n      }\n    }\n  }\n\n  for (const part of buffer.split(\"\\n\").filter(p => p !== \"\")) {\n    try {\n      yield JSON.parse(part);\n    } catch (error) {\n      console.warn(\"invalid json: \", part);\n    }\n  }\n};\n\nconst formatHost = host => {\n  if (!host) {\n    return \"http://127.0.0.1:11434\";\n  }\n\n  let isExplicitProtocol = host.includes(\"://\");\n\n  if (host.startsWith(\":\")) {\n    host = `http://127.0.0.1${host}`;\n    isExplicitProtocol = false;\n  }\n\n  if (!isExplicitProtocol) {\n    host = `http://${host}`;\n  }\n\n  const url = new URL(host);\n  let port = url.port;\n\n  if (!port) {\n    if (!isExplicitProtocol) {\n      port = \"11434\";\n    } else {\n      port = url.protocol === \"https:\" ? \"443\" : \"80\";\n    }\n  }\n\n  let formattedHost = `${url.protocol}//${url.hostname}:${port}${url.pathname}`;\n\n  if (formattedHost.endsWith(\"/\")) {\n    formattedHost = formattedHost.slice(0, -1);\n  }\n\n  return formattedHost;\n};\n\nvar __defProp = Object.defineProperty;\n\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\n\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n\n  return value;\n};\n\nlet Ollama$1 = class Ollama {\n  constructor(config) {\n    __publicField(this, \"config\");\n\n    __publicField(this, \"fetch\");\n\n    __publicField(this, \"abortController\");\n\n    this.config = {\n      host: \"\"\n    };\n\n    if (!config?.proxy) {\n      this.config.host = formatHost(config?.host ?? \"http://127.0.0.1:11434\");\n    }\n\n    this.fetch = fetch;\n\n    if (config?.fetch != null) {\n      this.fetch = config.fetch;\n    }\n\n    this.abortController = new AbortController();\n  } // Abort any ongoing requests to Ollama\n\n\n  abort() {\n    this.abortController.abort();\n    this.abortController = new AbortController();\n  }\n\n  async processStreamableRequest(endpoint, request) {\n    request.stream = request.stream ?? false;\n    const response = await post(this.fetch, `${this.config.host}/api/${endpoint}`, { ...request\n    }, {\n      signal: this.abortController.signal\n    });\n\n    if (!response.body) {\n      throw new Error(\"Missing body\");\n    }\n\n    const itr = parseJSON(response.body);\n\n    if (request.stream) {\n      return async function* () {\n        for await (const message of itr) {\n          if (\"error\" in message) {\n            throw new Error(message.error);\n          }\n\n          yield message;\n\n          if (message.done || message.status === \"success\") {\n            return;\n          }\n        }\n\n        throw new Error(\"Did not receive done or success response in stream.\");\n      }();\n    } else {\n      const message = await itr.next();\n\n      if (!message.value.done && message.value.status !== \"success\") {\n        throw new Error(\"Expected a completed response.\");\n      }\n\n      return message.value;\n    }\n  }\n\n  async encodeImage(image) {\n    if (typeof image !== \"string\") {\n      const uint8Array = new Uint8Array(image);\n      const numberArray = Array.from(uint8Array);\n      const base64String = btoa(String.fromCharCode.apply(null, numberArray));\n      return base64String;\n    }\n\n    return image;\n  }\n\n  async generate(request) {\n    if (request.images) {\n      request.images = await Promise.all(request.images.map(this.encodeImage.bind(this)));\n    }\n\n    return this.processStreamableRequest(\"generate\", request);\n  }\n\n  async chat(request) {\n    if (request.messages) {\n      for (const message of request.messages) {\n        if (message.images) {\n          message.images = await Promise.all(message.images.map(this.encodeImage.bind(this)));\n        }\n      }\n    }\n\n    return this.processStreamableRequest(\"chat\", request);\n  }\n\n  async create(request) {\n    return this.processStreamableRequest(\"create\", {\n      name: request.model,\n      stream: request.stream,\n      modelfile: request.modelfile\n    });\n  }\n\n  async pull(request) {\n    return this.processStreamableRequest(\"pull\", {\n      name: request.model,\n      stream: request.stream,\n      insecure: request.insecure\n    });\n  }\n\n  async push(request) {\n    return this.processStreamableRequest(\"push\", {\n      name: request.model,\n      stream: request.stream,\n      insecure: request.insecure\n    });\n  }\n\n  async delete(request) {\n    await del(this.fetch, `${this.config.host}/api/delete`, {\n      name: request.model\n    });\n    return {\n      status: \"success\"\n    };\n  }\n\n  async copy(request) {\n    await post(this.fetch, `${this.config.host}/api/copy`, { ...request\n    });\n    return {\n      status: \"success\"\n    };\n  }\n\n  async list() {\n    const response = await get(this.fetch, `${this.config.host}/api/tags`);\n    const listResponse = await response.json();\n    return listResponse;\n  }\n\n  async show(request) {\n    const response = await post(this.fetch, `${this.config.host}/api/show`, { ...request\n    });\n    const showResponse = await response.json();\n    return showResponse;\n  }\n\n  async embeddings(request) {\n    const response = await post(this.fetch, `${this.config.host}/api/embeddings`, { ...request\n    });\n    const embeddingsResponse = await response.json();\n    return embeddingsResponse;\n  }\n\n};\nconst browser = new Ollama$1();\nexport { Ollama$1 as O, browser as b, head as h, post as p };","map":{"version":3,"sources":["C:/Users/firdoz/Desktop/g project/New folder/learn_it/node_modules/ollama/dist/shared/ollama.be8fd0da.mjs"],"names":["version","ResponseError","Error","constructor","error","status_code","name","captureStackTrace","checkOk","response","ok","message","status","statusText","errorData","headers","get","includes","json","console","log","textResponse","text","getPlatform","window","navigator","platform","toLowerCase","userAgent","process","arch","fetchWithHeaders","fetch","url","options","defaultHeaders","Accept","host","head","method","post","data","isRecord","input","Array","isArray","formattedData","JSON","stringify","body","signal","del","parseJSON","itr","decoder","TextDecoder","buffer","reader","getReader","done","value","chunk","read","decode","parts","split","pop","part","parse","warn","filter","p","formatHost","isExplicitProtocol","startsWith","URL","port","protocol","formattedHost","hostname","pathname","endsWith","slice","__defProp","Object","defineProperty","__defNormalProp","obj","key","enumerable","configurable","writable","__publicField","Ollama$1","Ollama","config","proxy","abortController","AbortController","abort","processStreamableRequest","endpoint","request","stream","next","encodeImage","image","uint8Array","Uint8Array","numberArray","from","base64String","btoa","String","fromCharCode","apply","generate","images","Promise","all","map","bind","chat","messages","create","model","modelfile","pull","insecure","push","delete","copy","list","listResponse","show","showResponse","embeddings","embeddingsResponse","browser","O","b","h"],"mappings":"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","sourcesContent":["import 'whatwg-fetch';\n\nconst version = \"0.5.0\";\n\nclass ResponseError extends Error {\n  constructor(error, status_code) {\n    super(error);\n    this.error = error;\n    this.status_code = status_code;\n    this.name = \"ResponseError\";\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, ResponseError);\n    }\n  }\n}\nconst checkOk = async (response) => {\n  if (!response.ok) {\n    let message = `Error ${response.status}: ${response.statusText}`;\n    let errorData = null;\n    if (response.headers.get(\"content-type\")?.includes(\"application/json\")) {\n      try {\n        errorData = await response.json();\n        message = errorData.error || message;\n      } catch (error) {\n        console.log(\"Failed to parse error response as JSON\");\n      }\n    } else {\n      try {\n        console.log(\"Getting text from response\");\n        const textResponse = await response.text();\n        message = textResponse || message;\n      } catch (error) {\n        console.log(\"Failed to get text from error response\");\n      }\n    }\n    throw new ResponseError(message, response.status);\n  }\n};\nfunction getPlatform() {\n  if (typeof window !== \"undefined\" && window.navigator) {\n    return `${window.navigator.platform.toLowerCase()} Browser/${navigator.userAgent};`;\n  } else if (typeof process !== \"undefined\") {\n    return `${process.arch} ${process.platform} Node.js/${process.version}`;\n  }\n  return \"\";\n}\nconst fetchWithHeaders = async (fetch, url, options = {}) => {\n  const defaultHeaders = {\n    \"Content-Type\": \"application/json\",\n    Accept: \"application/json\",\n    \"User-Agent\": `ollama-js/${version} (${getPlatform()})`\n  };\n  if (!options.headers) {\n    options.headers = {};\n  }\n  options.headers = {\n    ...defaultHeaders,\n    ...options.headers\n  };\n  return fetch(url, options);\n};\nconst get = async (fetch, host) => {\n  const response = await fetchWithHeaders(fetch, host);\n  await checkOk(response);\n  return response;\n};\nconst head = async (fetch, host) => {\n  const response = await fetchWithHeaders(fetch, host, {\n    method: \"HEAD\"\n  });\n  await checkOk(response);\n  return response;\n};\nconst post = async (fetch, host, data, options) => {\n  const isRecord = (input) => {\n    return input !== null && typeof input === \"object\" && !Array.isArray(input);\n  };\n  const formattedData = isRecord(data) ? JSON.stringify(data) : data;\n  const response = await fetchWithHeaders(fetch, host, {\n    method: \"POST\",\n    body: formattedData,\n    signal: options?.signal\n  });\n  await checkOk(response);\n  return response;\n};\nconst del = async (fetch, host, data) => {\n  const response = await fetchWithHeaders(fetch, host, {\n    method: \"DELETE\",\n    body: JSON.stringify(data)\n  });\n  await checkOk(response);\n  return response;\n};\nconst parseJSON = async function* (itr) {\n  const decoder = new TextDecoder(\"utf-8\");\n  let buffer = \"\";\n  const reader = itr.getReader();\n  while (true) {\n    const { done, value: chunk } = await reader.read();\n    if (done) {\n      break;\n    }\n    buffer += decoder.decode(chunk);\n    const parts = buffer.split(\"\\n\");\n    buffer = parts.pop() ?? \"\";\n    for (const part of parts) {\n      try {\n        yield JSON.parse(part);\n      } catch (error) {\n        console.warn(\"invalid json: \", part);\n      }\n    }\n  }\n  for (const part of buffer.split(\"\\n\").filter((p) => p !== \"\")) {\n    try {\n      yield JSON.parse(part);\n    } catch (error) {\n      console.warn(\"invalid json: \", part);\n    }\n  }\n};\nconst formatHost = (host) => {\n  if (!host) {\n    return \"http://127.0.0.1:11434\";\n  }\n  let isExplicitProtocol = host.includes(\"://\");\n  if (host.startsWith(\":\")) {\n    host = `http://127.0.0.1${host}`;\n    isExplicitProtocol = false;\n  }\n  if (!isExplicitProtocol) {\n    host = `http://${host}`;\n  }\n  const url = new URL(host);\n  let port = url.port;\n  if (!port) {\n    if (!isExplicitProtocol) {\n      port = \"11434\";\n    } else {\n      port = url.protocol === \"https:\" ? \"443\" : \"80\";\n    }\n  }\n  let formattedHost = `${url.protocol}//${url.hostname}:${port}${url.pathname}`;\n  if (formattedHost.endsWith(\"/\")) {\n    formattedHost = formattedHost.slice(0, -1);\n  }\n  return formattedHost;\n};\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nlet Ollama$1 = class Ollama {\n  constructor(config) {\n    __publicField(this, \"config\");\n    __publicField(this, \"fetch\");\n    __publicField(this, \"abortController\");\n    this.config = {\n      host: \"\"\n    };\n    if (!config?.proxy) {\n      this.config.host = formatHost(config?.host ?? \"http://127.0.0.1:11434\");\n    }\n    this.fetch = fetch;\n    if (config?.fetch != null) {\n      this.fetch = config.fetch;\n    }\n    this.abortController = new AbortController();\n  }\n  // Abort any ongoing requests to Ollama\n  abort() {\n    this.abortController.abort();\n    this.abortController = new AbortController();\n  }\n  async processStreamableRequest(endpoint, request) {\n    request.stream = request.stream ?? false;\n    const response = await post(\n      this.fetch,\n      `${this.config.host}/api/${endpoint}`,\n      {\n        ...request\n      },\n      { signal: this.abortController.signal }\n    );\n    if (!response.body) {\n      throw new Error(\"Missing body\");\n    }\n    const itr = parseJSON(response.body);\n    if (request.stream) {\n      return async function* () {\n        for await (const message of itr) {\n          if (\"error\" in message) {\n            throw new Error(message.error);\n          }\n          yield message;\n          if (message.done || message.status === \"success\") {\n            return;\n          }\n        }\n        throw new Error(\"Did not receive done or success response in stream.\");\n      }();\n    } else {\n      const message = await itr.next();\n      if (!message.value.done && message.value.status !== \"success\") {\n        throw new Error(\"Expected a completed response.\");\n      }\n      return message.value;\n    }\n  }\n  async encodeImage(image) {\n    if (typeof image !== \"string\") {\n      const uint8Array = new Uint8Array(image);\n      const numberArray = Array.from(uint8Array);\n      const base64String = btoa(String.fromCharCode.apply(null, numberArray));\n      return base64String;\n    }\n    return image;\n  }\n  async generate(request) {\n    if (request.images) {\n      request.images = await Promise.all(request.images.map(this.encodeImage.bind(this)));\n    }\n    return this.processStreamableRequest(\"generate\", request);\n  }\n  async chat(request) {\n    if (request.messages) {\n      for (const message of request.messages) {\n        if (message.images) {\n          message.images = await Promise.all(\n            message.images.map(this.encodeImage.bind(this))\n          );\n        }\n      }\n    }\n    return this.processStreamableRequest(\"chat\", request);\n  }\n  async create(request) {\n    return this.processStreamableRequest(\"create\", {\n      name: request.model,\n      stream: request.stream,\n      modelfile: request.modelfile\n    });\n  }\n  async pull(request) {\n    return this.processStreamableRequest(\"pull\", {\n      name: request.model,\n      stream: request.stream,\n      insecure: request.insecure\n    });\n  }\n  async push(request) {\n    return this.processStreamableRequest(\"push\", {\n      name: request.model,\n      stream: request.stream,\n      insecure: request.insecure\n    });\n  }\n  async delete(request) {\n    await del(this.fetch, `${this.config.host}/api/delete`, {\n      name: request.model\n    });\n    return { status: \"success\" };\n  }\n  async copy(request) {\n    await post(this.fetch, `${this.config.host}/api/copy`, { ...request });\n    return { status: \"success\" };\n  }\n  async list() {\n    const response = await get(this.fetch, `${this.config.host}/api/tags`);\n    const listResponse = await response.json();\n    return listResponse;\n  }\n  async show(request) {\n    const response = await post(this.fetch, `${this.config.host}/api/show`, {\n      ...request\n    });\n    const showResponse = await response.json();\n    return showResponse;\n  }\n  async embeddings(request) {\n    const response = await post(this.fetch, `${this.config.host}/api/embeddings`, {\n      ...request\n    });\n    const embeddingsResponse = await response.json();\n    return embeddingsResponse;\n  }\n};\nconst browser = new Ollama$1();\n\nexport { Ollama$1 as O, browser as b, head as h, post as p };\n"]},"metadata":{},"sourceType":"module"}